import pandas as pd
import math
import re
from collections import Counter
from typing import List, Dict

class KnowledgeBase:
    """
    –ë–∞–∑–∞ –≤–æ–ø—Ä–æ—Å–æ–≤-–æ—Ç–≤–µ—Ç–æ–≤ —Å –ø–æ–∏—Å–∫–æ–º –ø–æ TF-IDF + –∫–æ—Å–∏–Ω—É—Å–Ω–æ–º—É —Å—Ö–æ–¥—Å—Ç–≤—É.
    """
    # –ù–∞–±–æ—Ä —Å—Ç–æ–ø‚Äë—Å–ª–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ —É–±–∏—Ä–∞–µ–º
    STOP_WORDS = {
        "—á—Ç–æ","–≥–¥–µ","–∫–∞–∫","–ø–æ—á–µ–º—É","–∫–æ–≥–¥–∞","—á—Ç–æ–±—ã","—ç—Ç–æ",
        "–∏","–≤","–Ω–∞","—Å","–ø–æ","–∑–∞","–Ω–µ","—è","—Ç—ã","–æ–Ω","–æ–Ω–∞","–æ–Ω–∏","–º—ã",
        # –º–æ–∂–Ω–æ —Ä–∞—Å—à–∏—Ä–∏—Ç—å –ø–æ–¥ –∑–∞–¥–∞—á–∏
    }

    def __init__(self, excel_path: str, sheet_name=0):
        """
        1. –°—á–∏—Ç—ã–≤–∞–µ–º Excel: –∫–æ–ª–æ–Ω–∫–∏ 'Question' –∏ 'Answer'.
        2. –ü—Ä–µ–¥–æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–∞–∂–¥—ã–π –≤–æ–ø—Ä–æ—Å: —Ç–æ–∫–µ–Ω–∏–∑–∏—Ä—É–µ–º, —É–±–∏—Ä–∞–µ–º —Å—Ç–æ–ø‚Äë—Å–ª–æ–≤–∞.
        3. –°—Ç—Ä–æ–∏–º TF-IDF –º–∞—Ç—Ä–∏—Ü—É:
           - idf[w] = log(N / df[w])
           - –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –¥–æ–∫—É–º–µ–Ω—Ç–∞ —Ö—Ä–∞–Ω–∏—Ç—Å—è dict: {w: tfidf(w, doc)}
        """
        df = pd.read_excel(excel_path, sheet_name=sheet_name)
        if not {"Question","Answer"}.issubset(df.columns):
            raise ValueError("–í Excel –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —Å—Ç–æ–ª–±—Ü—ã 'Question' –∏ 'Answer'")

        # –ß–∏—Ç–∞–µ–º –ø–∞—Ä—ã
        self.qa = []
        for q, a in zip(df['Question'].astype(str), df['Answer'].astype(str)):
            q_clean = q.strip()
            if not q_clean:
                continue
            tokens = self._tokenize(q_clean)
            tokens = [t for t in tokens if t not in self.STOP_WORDS]
            if not tokens:
                continue
            self.qa.append((tokens, a))

        # –í—Å–µ–≥–æ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤
        self.N = len(self.qa)

        # –°—á–∏—Ç–∞–µ–º –¥–æ–∫—É–º–µ–Ω—Ç–Ω—ã–µ —á–∞—Å—Ç–æ—Ç—ã df[w]
        df_counts: Dict[str, int] = {}
        for tokens, _ in self.qa:
            unique = set(tokens)
            for w in unique:
                df_counts[w] = df_counts.get(w, 0) + 1

        # –°—á–∏—Ç–∞–µ–º idf
        self.idf: Dict[str, float] = {}
        for w, dfw in df_counts.items():
            # –î–æ–±–∞–≤–ª—è–µ–º +1 –≤ –∑–Ω–∞–º–µ–Ω–∞—Ç–µ–ª–µ –¥–ª—è —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è
            self.idf[w] = math.log((self.N + 1) / (dfw + 1)) + 1.0

        # –°—Ç—Ä–æ–∏–º TF-IDF –≤–µ–∫—Ç–æ—Ä—ã –∏ –∏—Ö –Ω–æ—Ä–º—ã
        self.doc_tfidf: List[Dict[str, float]] = []
        self.doc_norm: List[float] = []
        for tokens, _ in self.qa:
            tf = Counter(tokens)
            # —Å—Ç—Ä–æ–∏–º tf-idf: tfidf = tf[w] * idf[w]
            vec = {w: tf[w] * self.idf[w] for w in tf}
            norm = math.sqrt(sum(v * v for v in vec.values()))
            self.doc_tfidf.append(vec)
            self.doc_norm.append(norm)

    @staticmethod
    def _tokenize(text: str) -> List[str]:
        """
        –£–±–∏—Ä–∞–µ–º –≤—Å–µ, –∫—Ä–æ–º–µ –±—É–∫–≤ –∏ —Ü–∏—Ñ—Ä, –ø—Ä–∏–≤–æ–¥–∏–º –∫ –Ω–∏–∂–Ω–µ–º—É —Ä–µ–≥–∏—Å—Ç—Ä—É,
        —Ä–∞–∑–±–∏–≤–∞–µ–º –ø–æ –ø—Ä–æ–±–µ–ª–∞–º.
        """
        text = re.sub(r'[^0-9A-Za-z–ê-–Ø–∞-—è–Å—ë]+', ' ', text.lower())
        return [tok for tok in text.split() if tok]

    @staticmethod
    def _cosine(vec1: Dict[str, float], vec2: Dict[str, float],
                norm1: float, norm2: float) -> float:
        """
        –ö–æ—Å–∏–Ω—É—Å–Ω–æ–µ —Å—Ö–æ–¥—Å—Ç–≤–æ: dot(vec1, vec2) / (norm1 * norm2)
        –ï—Å–ª–∏ –æ–¥–∏–Ω –∏–∑ –≤–µ–∫—Ç–æ—Ä–æ–≤ –Ω—É–ª–µ–≤–æ–π, –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç 0.0
        """
        if norm1 == 0 or norm2 == 0:
            return 0.0
        # –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ –∫–ª—é—á–µ–π
        dot = sum(vec1[k] * vec2.get(k, 0.0) for k in vec1)
        return dot / (norm1 * norm2)

    def find_best_answer(self, query: str, threshold: float = 0.2) -> str:
        """
        –ò—â–µ–º –ª—É—á—à–∏–π –æ—Ç–≤–µ—Ç –Ω–∞ query:
        1. –¢–æ–∫–µ–Ω–∏–∑–∏—Ä—É–µ–º –∏ —Ñ–∏–ª—å—Ç—Ä—É–µ–º query.
        2. –°—Ç—Ä–æ–∏–º tf-idf –≤–µ–∫—Ç–æ—Ä –¥–ª—è query (–∏—Å–ø–æ–ª—å–∑—É–µ–º idf –∏–∑ –∫–æ—Ä–ø—É—Å–∞).
        3. –°—á–∏—Ç–∞–µ–º –∫–æ—Å–∏–Ω—É—Å–Ω–æ–µ —Å—Ö–æ–¥—Å—Ç–≤–æ —Å –∫–∞–∂–¥—ã–º –¥–æ–∫—É–º–µ–Ω—Ç–æ–º.
        4. –ï—Å–ª–∏ max(sim) >= threshold, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Å–≤—è–∑–∞–Ω–Ω—ã–π answer,
           –∏–Ω–∞—á–µ ‚Äî –æ—Ç–∫–∞–∑.
        """
        # –ü—Ä–µ–¥–æ–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–ø—Ä–æ—Å–∞
        tokens = self._tokenize(query)
        tokens = [t for t in tokens if t not in self.STOP_WORDS]
        if not tokens:
            return "–ò–∑–≤–∏–Ω–∏—Ç–µ, —è –ø–æ–∫–∞ –Ω–µ –º–æ–≥—É –æ—Ç–≤–µ—Ç–∏—Ç—å –Ω–∞ —ç—Ç–æ—Ç –≤–æ–ø—Ä–æ—Å."

        # tf –¥–ª—è –∑–∞–ø—Ä–æ—Å–∞
        tfq = Counter(tokens)
        # —Å—Ç—Ä–æ–∏–º –≤–µ–∫—Ç–æ—Ä query
        vecq = {w: tfq[w] * self.idf.get(w, math.log((self.N+1)/1)+1.0)
                for w in tfq}
        normq = math.sqrt(sum(v * v for v in vecq.values()))

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥–æ–µ doc
        best_idx, best_sim = -1, 0.0
        for i, (doc_vec, doc_norm) in enumerate(zip(self.doc_tfidf, self.doc_norm)):
            sim = self._cosine(vecq, doc_vec, normq, doc_norm)
            if sim > best_sim:
                best_sim = sim
                best_idx = i

        # –ï—Å–ª–∏ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø–æ—Ö–æ–∂–∏ ‚Äî –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—Ç–≤–µ—Ç
        if best_sim >= threshold and best_idx >= 0:
            return self.qa[best_idx][1]

        return "–ò–∑–≤–∏–Ω–∏—Ç–µ, —è –ø–æ–∫–∞ –Ω–µ –º–æ–≥—É –æ—Ç–≤–µ—Ç–∏—Ç—å –Ω–∞ —ç—Ç–æ—Ç –≤–æ–ø—Ä–æ—Å."


# -------------
# –ü—Ä–∏–º–µ—Ä
# -------------
if __name__ == "__main__":
    kb = KnowledgeBase("knowledge_base.xlsx")
    print("–ë–∞–∑–∞ –∑–∞–≥—Ä—É–∂–µ–Ω–∞. –í–≤–µ–¥–∏—Ç–µ –≤–æ–ø—Ä–æ—Å:")
    while True:
        q = input("> ").strip()
        if not q:
            break
        print("–ë–æ—Ç:", kb.find_best_answer(q, threshold=0.2))









# handlers/admin_commands.py

from dialog_bot_sdk.entities.messaging import CommandHandler
from dialog_bot_sdk.entities.peers     import PeerType
from config.config                    import ADMIN_IDS
from infrastructure.sber_sdk           import sber_bot
from infrastructure.excel_repository   import ExcelRepository

# –ü—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º, —á—Ç–æ excel_repo —Å–æ–∑–¥–∞–Ω (–Ω–∞–ø—Ä–∏–º–µ—Ä, –≤ main –∏ –ø–µ—Ä–µ–¥–∞–Ω —Å—é–¥–∞)
excel_repo = ExcelRepository("knowledge_base.xlsx", "bot_logs.xlsx")

def is_admin(message):
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —á—Ç–æ sender_peer.id –µ—Å—Ç—å –≤ —Å–ø–∏—Å–∫–µ –∞–¥–º–∏–Ω–æ–≤."""
    return message.sender_peer.id in ADMIN_IDS

# --- –ö–æ–º–∞–Ω–¥–∞ 1: –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–æ–≤–æ–π –ø–∞—Ä—ã –í–æ–ø—Ä–æ—Å;–û—Ç–≤–µ—Ç ---
def add_qa_handler(update):
    # update: UpdateMessage
    peer   = update.peer
    sender = update.sender_peer

    if not is_admin(update):
        return sber_bot.messaging.send_message(peer, "‚ùå –¢–æ–ª—å–∫–æ –∞–¥–º–∏–Ω—ã –º–æ–≥—É—Ç —É–ø—Ä–∞–≤–ª—è—Ç—å –±–∞–∑–æ–π –∑–Ω–∞–Ω–∏–π.")

    # –æ–∂–∏–¥–∞–µ–º —Ç–µ–∫—Å—Ç –≤–∏–¥–∞: "–í–æ–ø—Ä–æ—Å?;–û—Ç–≤–µ—Ç!"
    payload = update.message.text_message.text
    try:
        # —É–±–∏—Ä–∞–µ–º –∫–æ–º–∞–Ω–¥—É "/add_qa " –≤ –Ω–∞—á–∞–ª–µ
        _, body = payload.split(" ", 1)
        question, answer = [p.strip() for p in body.split(";", 1)]
    except ValueError:
        return sber_bot.messaging.send_message(
            peer, "‚ùó –§–æ—Ä–º–∞—Ç: /add_qa –í–æ–ø—Ä–æ—Å?; –û—Ç–≤–µ—Ç!"
        )

    # –î–æ–±–∞–≤–ª—è–µ–º –≤ Excel (—Ä–µ–∞–ª–∏–∑—É–π—Ç–µ —ç—Ç–æ—Ç –º–µ—Ç–æ–¥ –≤ ExcelRepository)
    excel_repo.add_qa(question, answer)
    sber_bot.messaging.send_message(peer, f"‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–æ: ¬´{question}¬ª ‚Üí ¬´{answer}¬ª.")


# --- –ö–æ–º–∞–Ω–¥–∞ 2: —É–¥–∞–ª–µ–Ω–∏–µ –ø–∞—Ä—ã –ø–æ –≤–æ–ø—Ä–æ—Å—É ---
def delete_qa_handler(update):
    peer   = update.peer
    sender = update.sender_peer

    if not is_admin(update):
        return sber_bot.messaging.send_message(peer, "‚ùå –¢–æ–ª—å–∫–æ –∞–¥–º–∏–Ω—ã –º–æ–≥—É—Ç —É–ø—Ä–∞–≤–ª—è—Ç—å –±–∞–∑–æ–π –∑–Ω–∞–Ω–∏–π.")

    # –æ–∂–∏–¥–∞–µ–º —Ç–µ–∫—Å—Ç –≤–∏–¥–∞: "/del_qa –í–æ–ø—Ä–æ—Å?"
    parts = update.message.text_message.text.split(" ", 1)
    if len(parts) < 2 or not parts[1].strip():
        return sber_bot.messaging.send_message(peer, "‚ùó –§–æ—Ä–º–∞—Ç: /del_qa –í–æ–ø—Ä–æ—Å?")
    question = parts[1].strip()

    # –£–¥–∞–ª—è–µ–º –≤ Excel (—Ä–µ–∞–ª–∏–∑—É–π—Ç–µ —ç—Ç–æ—Ç –º–µ—Ç–æ–¥)
    deleted = excel_repo.delete_qa(question)
    if deleted:
        sber_bot.messaging.send_message(peer, f"üóë –ü–∞—Ä–∞ —Å –≤–æ–ø—Ä–æ—Å–æ–º ¬´{question}¬ª —É–¥–∞–ª–µ–Ω–∞.")
    else:
        sber_bot.messaging.send_message(peer, f"‚ùå –ù–µ –Ω–∞—à—ë–ª –≤–æ–ø—Ä–æ—Å ¬´{question}¬ª –≤ –±–∞–∑–µ.")


# --- –ö–æ–º–∞–Ω–¥–∞ 3: –æ—Ç–ø—Ä–∞–≤–∫–∞ Excel-—Ñ–∞–π–ª–∞ –±–∞–∑—ã –∑–Ω–∞–Ω–∏–π ---
def export_kb_handler(update):
    peer   = update.peer
    sender = update.sender_peer

    if not is_admin(update):
        return sber_bot.messaging.send_message(peer, "‚ùå –¢–æ–ª—å–∫–æ –∞–¥–º–∏–Ω—ã –º–æ–≥—É—Ç –≤—ã–≥—Ä—É–∂–∞—Ç—å –±–∞–∑—É –∑–Ω–∞–Ω–∏–π.")

    path = excel_repo.kb_path  # –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É knowledge_base.xlsx
    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ñ–∞–π–ª –≤ —á–∞—Ç
    sber_bot.messaging.send_file(peer, path, text="üì¶ –í–æ—Ç –∞–∫—Ç—É–∞–ª—å–Ω–∞—è –±–∞–∑–∞ –∑–Ω–∞–Ω–∏–π:")





from dialog_bot_sdk.entities.messaging import CommandHandler
from dialog_bot_sdk.entities.peers     import PeerType
from infrastructure.sber_sdk           import sber_bot
from handlers.admin_commands           import (
    add_qa_handler,
    delete_qa_handler,
    export_kb_handler,
)

# –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –∫–æ–º–∞–Ω–¥—ã (—Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∞–º, –Ω–æ PeerType.PEERTYPE_PRIVATE —É–¥–æ–±–Ω–µ–µ)
sber_bot.messaging.command_handler([
    CommandHandler(add_qa_handler,    "add_qa",  PeerType.PEERTYPE_PRIVATE, description="–î–æ–±–∞–≤–∏—Ç—å –≤–æ–ø—Ä–æ—Å;–æ—Ç–≤–µ—Ç"),
    CommandHandler(delete_qa_handler, "del_qa",  PeerType.PEERTYPE_PRIVATE, description="–£–¥–∞–ª–∏—Ç—å –ø–æ –≤–æ–ø—Ä–æ—Å—É"),
    CommandHandler(export_kb_handler, "export_kb", PeerType.PEERTYPE_PRIVATE, description="–í—ã–≥—Ä—É–∑–∏—Ç—å Excel –±–∞–∑—ã –∑–Ω–∞–Ω–∏–π"),
])




from openpyxl import load_workbook

class ExcelRepository:
    def __init__(self, kb_path: str, log_path: str):
        self.kb_path  = kb_path
        # ‚Ä¶ –æ—Å—Ç–∞–ª—å–Ω–æ–π –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä

    def add_qa(self, question: str, answer: str):
        """–î–æ–±–∞–≤–ª—è–µ—Ç –Ω–æ–≤—É—é —Å—Ç—Ä–æ–∫—É –≤ –Ω–∞—á–∞–ª–æ/–∫–æ–Ω–µ—Ü –ª–∏—Å—Ç–∞ –±–∞–∑—ã –∑–Ω–∞–Ω–∏–π."""
        wb = load_workbook(self.kb_path)
        ws = wb.active
        ws.append([question, answer])
        wb.save(self.kb_path)

    def delete_qa(self, question: str) -> bool:
        """
        –£–¥–∞–ª—è–µ—Ç –ø–µ—Ä–≤—É—é –Ω–∞–π–¥–µ–Ω–Ω—É—é —Å—Ç—Ä–æ–∫—É, –≥–¥–µ –∫–æ–ª–æ–Ω–∫–∞ 'Question' == question.
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç True, –µ—Å–ª–∏ —É–¥–∞–ª–∏–ª–∏, –∏–Ω–∞—á–µ False.
        """
        wb = load_workbook(self.kb_path)
        ws = wb.active
        found = False
        # –ò—â–µ–º –≤–æ –≤—Å–µ—Ö —Å—Ç—Ä–æ–∫–∞—Ö, –Ω–∞—á–∏–Ω–∞—è —Å 2‚Äë–π (–ø—Ä–æ–ø—É—Å–∫–∞–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫)
        for row in list(ws.iter_rows(min_row=2)):
            cell = row[0]  # –ø–µ—Ä–≤—ã–π —Å—Ç–æ–ª–±–µ—Ü ‚Äî –≤–æ–ø—Ä–æ—Å
            if str(cell.value).strip() == question:
                ws.delete_rows(cell.row, 1)
                found = True
                break
        if found:
            wb.save(self.kb_path)
        return found
