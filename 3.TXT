onboarding_sberchat/
‚îÇ
‚îú‚îÄ‚îÄ main.py
‚îÇ
‚îú‚îÄ‚îÄ requirements.txt
‚îÇ
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îî‚îÄ‚îÄ settings.py
‚îÇ
‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ message.py
‚îÇ   ‚îî‚îÄ‚îÄ services/
‚îÇ       ‚îî‚îÄ‚îÄ knowledge_search.py    ‚Üê –≤–æ—Ç –∑–¥–µ—Å—å –≤–∞—à —á–∏—Å—Ç—ã–π TF‚ÄëIDF –º–æ–¥—É–ª—å
‚îÇ
‚îú‚îÄ‚îÄ application/
‚îÇ   ‚îî‚îÄ‚îÄ handlers/
‚îÇ       ‚îî‚îÄ‚îÄ message_handler.py
‚îÇ
‚îú‚îÄ‚îÄ infrastructure/
‚îÇ   ‚îú‚îÄ‚îÄ excel/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ excel_repository.py
‚îÇ   ‚îî‚îÄ‚îÄ sberchat/
‚îÇ       ‚îî‚îÄ‚îÄ sber_bot.py
‚îÇ
‚îî‚îÄ‚îÄ knowledge_base.xlsx


1. config/settings.py
import os

BOT_ENDPOINT = os.getenv("BOT_ENDPOINT", "epbotsandbox.sberchat.sberbank.ru")
BOT_TOKEN    = os.getenv("BOT_TOKEN", "")
BOT_NAME     = os.getenv("BOT_NAME", "rmoconboarding")
ADMIN_IDS    = {int(x) for x in os.getenv("ADMIN_IDS", "").split(",") if x}

# –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
import logging
logger = logging.getLogger("sber_bot")
logger.setLevel(logging.INFO)
ch = logging.StreamHandler()
ch.setFormatter(logging.Formatter("%(asctime)s [%(levelname)s] %(message)s"))




2. domain/models/message.py
from dataclasses import dataclass
from datetime import datetime

@dataclass
class FullLogEntry:
    user: str
    text: str
    timestamp: datetime
    source: str



3. domain/services/knowledge_search.py
import pandas as pd
import math
import re
from collections import Counter
from typing import List, Dict, Tuple

class KnowledgeSearch:
    """
    –ü–æ–∏—Å–∫ –æ—Ç–≤–µ—Ç–∞ –≤ –±–∞–∑–µ –∑–Ω–∞–Ω–∏–π –Ω–∞ –æ—Å–Ω–æ–≤–µ TF-IDF + –∫–æ—Å–∏–Ω—É—Å–Ω–æ–≥–æ —Å—Ö–æ–¥—Å—Ç–≤–∞.
    """

    # –°—Ç–æ–ø‚Äë—Å–ª–æ–≤–∞, –∫–æ—Ç–æ—Ä—ã–µ —É–¥–∞–ª—è–µ–º –ø–µ—Ä–µ–¥ –∞–Ω–∞–ª–∏–∑–æ–º
    STOP_WORDS = {
        "—á—Ç–æ","–≥–¥–µ","–∫–∞–∫","–ø–æ—á–µ–º—É","–∫–æ–≥–¥–∞","—á—Ç–æ–±—ã","—ç—Ç–æ",
        "–∏","–≤","–Ω–∞","—Å","–ø–æ","–∑–∞","–Ω–µ","—è","—Ç—ã","–æ–Ω","–æ–Ω–∞","–æ–Ω–∏","–º—ã",
    }

    def __init__(self, excel_path: str, sheet_name=0):
        """
        1) –ó–∞–≥—Ä—É–∂–∞–µ–º Excel: –∫–æ–ª–æ–Ω–∫–∏ 'Question' –∏ 'Answer'.
        2) –¢–æ–∫–µ–Ω–∏–∑–∏—Ä—É–µ–º –∏ —É–¥–∞–ª—è–µ–º —Å—Ç–æ–ø‚Äë—Å–ª–æ–≤–∞.
        3) –°—á–∏—Ç–∞–µ–º TF-IDF –º–∞—Ç—Ä–∏—Ü—É –∏ –Ω–æ—Ä–º—É –∫–∞–∂–¥–æ–≥–æ –≤–µ–∫—Ç–æ—Ä–∞.
        """
        df = pd.read_excel(excel_path, sheet_name=sheet_name)
        if not {"Question","Answer"}.issubset(df.columns):
            raise ValueError("–í Excel-—Ñ–∞–π–ª–µ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –∫–æ–ª–æ–Ω–∫–∏ 'Question' –∏ 'Answer'")

        # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º —Å–ø–∏—Å–æ–∫ –ø–∞—Ä (—Ç–æ–∫–µ–Ω—ã_–≤–æ–ø—Ä–æ—Å–∞, –æ—Ç–≤–µ—Ç)
        self.qa: List[Tuple[List[str], str]] = []
        for q, a in zip(df["Question"].astype(str), df["Answer"].astype(str)):
            tokens = self._tokenize(q)
            tokens = [w for w in tokens if w not in self.STOP_WORDS]
            if tokens:
                self.qa.append((tokens, a))

        # –û–±—â–µ–µ —á–∏—Å–ª–æ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤
        self.N = len(self.qa)

        # –°—á–∏—Ç–∞–µ–º –¥–æ–∫—É–º–µ–Ω—Ç–Ω—ã–µ —á–∞—Å—Ç–æ—Ç—ã df[w]
        df_counts: Dict[str,int] = {}
        for tokens, _ in self.qa:
            for w in set(tokens):
                df_counts[w] = df_counts.get(w, 0) + 1

        # –í—ã—á–∏—Å–ª—è–µ–º idf[w] = log((N+1)/(df[w]+1)) + 1
        self.idf: Dict[str,float] = {
            w: math.log((self.N+1)/(df_counts[w]+1)) + 1.0
            for w in df_counts
        }

        # –°—Ç—Ä–æ–∏–º TF-IDF –≤–µ–∫—Ç–æ—Ä—ã –∏ –Ω–æ—Ä–º—ã
        self.doc_tfidf: List[Dict[str,float]] = []
        self.doc_norm:   List[float] = []
        for tokens, _ in self.qa:
            tf = Counter(tokens)
            vec = {w: tf[w] * self.idf[w] for w in tf}
            norm = math.sqrt(sum(v*v for v in vec.values()))
            self.doc_tfidf.append(vec)
            self.doc_norm.append(norm)

    @staticmethod
    def _tokenize(text: str) -> List[str]:
        """
        –ü—Ä–∏–≤–æ–¥–∏–º –∫ –Ω–∏–∂–Ω–µ–º—É —Ä–µ–≥–∏—Å—Ç—Ä—É, –æ—Å—Ç–∞–≤–ª—è–µ–º –±—É–∫–≤—ã/—Ü–∏—Ñ—Ä—ã,
        —Ä–∞–∑–¥–µ–ª—è–µ–º –ø–æ –ø—Ä–æ–±–µ–ª–∞–º.
        """
        cleaned = re.sub(r'[^0-9A-Za-z–ê-–Ø–∞-—è–Å—ë]+', ' ', text.lower())
        return [tok for tok in cleaned.split() if tok]

    @staticmethod
    def _cosine(v1: Dict[str,float], v2: Dict[str,float], n1: float, n2: float) -> float:
        """
        –ö–æ—Å–∏–Ω—É—Å–Ω–æ–µ —Å—Ö–æ–¥—Å—Ç–≤–æ –º–µ–∂–¥—É –¥–≤—É–º—è –≤–µ–∫—Ç–æ—Ä–∞–º–∏ (—Å–ª–æ–≤–∞—Ä–∏ TF-IDF).
        """
        if n1 == 0 or n2 == 0:
            return 0.0
        dot = sum(v1[k] * v2.get(k,0.0) for k in v1)
        return dot / (n1 * n2)

    def find_best_answer(self, query: str, threshold: float = 0.2) -> str:
        """
        –ò—â–µ—Ç –ª—É—á—à–∏–π –æ—Ç–≤–µ—Ç –Ω–∞ query.
        –ï—Å–ª–∏ max_similarity >= threshold ‚Äî –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ—Ç–≤–µ—Ç,
        –∏–Ω–∞—á–µ ‚Äî –≤–µ–∂–ª–∏–≤–æ–µ –∏–∑–≤–∏–Ω–µ–Ω–∏–µ.
        """
        # –¢–æ–∫–µ–Ω–∏–∑–∏—Ä—É–µ–º –∏ —Ñ–∏–ª—å—Ç—Ä—É–µ–º
        tokens = self._tokenize(query)
        tokens = [w for w in tokens if w not in self.STOP_WORDS]
        if not tokens:
            return "–ò–∑–≤–∏–Ω–∏—Ç–µ, —è –ø–æ–∫–∞ –Ω–µ –º–æ–≥—É –æ—Ç–≤–µ—Ç–∏—Ç—å –Ω–∞ —ç—Ç–æ—Ç –≤–æ–ø—Ä–æ—Å."

        # –°—Ç—Ä–æ–∏–º TF-IDF –≤–µ–∫—Ç–æ—Ä –¥–ª—è –∑–∞–ø—Ä–æ—Å–∞
        tfq = Counter(tokens)
        vecq = {w: tfq[w] * self.idf.get(w, math.log((self.N+1)/1)+1.0)
                for w in tfq}
        normq = math.sqrt(sum(v*v for v in vecq.values()))

        # –°—Ä–∞–≤–Ω–∏–≤–∞–µ–º —Å –∫–∞–∂–¥—ã–º –¥–æ–∫—É–º–µ–Ω—Ç–æ–º
        best_sim, best_idx = 0.0, -1
        for i, (doc_vec, doc_norm) in enumerate(zip(self.doc_tfidf, self.doc_norm)):
            sim = self._cosine(vecq, doc_vec, normq, doc_norm)
            if sim > best_sim:
                best_sim, best_idx = sim, i

        if best_sim >= threshold:
            return self.qa[best_idx][1]
        return "–ò–∑–≤–∏–Ω–∏—Ç–µ, —è –ø–æ–∫–∞ –Ω–µ –º–æ–≥—É –æ—Ç–≤–µ—Ç–∏—Ç—å –Ω–∞ —ç—Ç–æ—Ç –≤–æ–ø—Ä–æ—Å."



4. infrastructure/excel/excel_repository.py
import os
import pandas as pd
from openpyxl import Workbook
from domain.models.message import FullLogEntry
from config.settings import logger

class ExcelRepository:
    def __init__(self):
        self.kb_path      = "knowledge_base.xlsx"
        self.log_path     = "full_chat_log.xlsx"
        self.feedback_path= "feedback_data.xlsx"
        self._init_file(self.log_path,     ["User","Text","Timestamp","Source"])
        self._init_file(self.feedback_path,["Question","Answer","Feedback","Timestamp"])

    def _init_file(self, path, cols):
        if not os.path.exists(path):
            pd.DataFrame(columns=cols).to_excel(path, index=False)
            logger.info(f"–°–æ–∑–¥–∞–Ω —Ñ–∞–π–ª {path}")

    def append_full_log(self, entry: FullLogEntry):
        df = pd.read_excel(self.log_path)
        df.loc[len(df)] = [entry.user, entry.text, entry.timestamp, entry.source]
        df.to_excel(self.log_path, index=False)

    def append_feedback(self, question, answer, feedback, timestamp):
        df = pd.read_excel(self.feedback_path)
        df.loc[len(df)] = [question, answer, feedback, timestamp]
        df.to_excel(self.feedback_path, index=False)





5. infrastructure/sberchat/sber_bot.py
from dialog_bot_sdk.bot import DialogBot
from config.settings import BOT_ENDPOINT, BOT_TOKEN, logger

class SberBot:
    def __init__(self):
        self.bot = DialogBot.get_secure_bot(BOT_ENDPOINT, BOT_TOKEN)
        self.messaging = self.bot.messaging
        self.updates   = self.bot.updates
        logger.info("SberBot –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")

    def start_polling(self):
        self.updates.on_updates(do_read_message=True, do_register_commands=True)

sber_bot = SberBot()




6. application/handlers/message_handler.py
from dialog_bot_sdk.entities.messaging import MessageHandler, MessageContentType
from dialog_bot_sdk.entities.peers import PeerType
from config.settings import BOT_NAME, ADMIN_IDS
from infrastructure.sberchat.sber_bot import sber_bot
from infrastructure.excel.excel_repository import ExcelRepository
from domain.services.knowledge_search import KnowledgeSearch
from datetime import datetime

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–µ–≤ –∏ –ø–æ–∏—Å–∫–æ–≤–∏–∫–∞
excel_repo = ExcelRepository()
kb_search  = KnowledgeSearch("knowledge_base.xlsx")

def strip_mention(text: str) -> str:
    return text.lower().replace(f"@{BOT_NAME}".lower(), "").strip()

def is_admin(uid: int) -> bool:
    return uid in ADMIN_IDS

def handle_message(update):
    peer = update.peer
    msg  = update.message
    if msg.text_message is None:
        return

    raw = msg.text_message.text.strip()
    text= strip_mention(raw)

    # –í –≥—Ä—É–ø–ø–µ ‚Äî —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –µ—Å—Ç—å —Ç–µ–≥
    if peer.type == PeerType.PEERTYPE_GROUP:
        if BOT_NAME.lower() not in raw.lower():
            return
    else:
        # –í –ª–∏—á–∫–µ ‚Äî —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω—ã
        if not is_admin(update.sender_peer.id):
            return

    # –õ–æ–≥–∏—Ä—É–µ–º –∑–∞–ø—Ä–æ—Å
    excel_repo.append_full_log(
        FullLogEntry(user=str(update.sender_peer.id), text=text,
                     timestamp=datetime.now(), source="user")
    )

    # –ò—â–µ–º –æ—Ç–≤–µ—Ç
    answer = kb_search.find_best_answer(text, threshold=0.2)
    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º
    sber_bot.messaging.send_message(peer, answer)

# –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º
sber_bot.messaging.message_handler([
    MessageHandler(handle_message, MessageContentType.TEXT_MESSAGE)
])





7. main.py
from config.settings import logger
from infrastructure.sberchat.sber_bot import sber_bot
import application.handlers.message_handler  # —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ—Ç —Ö–µ–Ω–¥–ª–µ—Ä—ã

def main():
    logger.info("–ó–∞–ø—É—Å–∫...")
    sber_bot.start_polling()

if __name__ == "__main__":
    main()














































import pandas as pd
import math
import re
from collections import Counter
from typing import List, Dict

class KnowledgeBase:
    """
    –ë–∞–∑–∞ –≤–æ–ø—Ä–æ—Å–æ–≤-–æ—Ç–≤–µ—Ç–æ–≤ —Å –ø–æ–∏—Å–∫–æ–º –ø–æ TF-IDF + –∫–æ—Å–∏–Ω—É—Å–Ω–æ–º—É —Å—Ö–æ–¥—Å—Ç–≤—É.
    """
    # –ù–∞–±–æ—Ä —Å—Ç–æ–ø‚Äë—Å–ª–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ —É–±–∏—Ä–∞–µ–º
    STOP_WORDS = {
        "—á—Ç–æ","–≥–¥–µ","–∫–∞–∫","–ø–æ—á–µ–º—É","–∫–æ–≥–¥–∞","—á—Ç–æ–±—ã","—ç—Ç–æ",
        "–∏","–≤","–Ω–∞","—Å","–ø–æ","–∑–∞","–Ω–µ","—è","—Ç—ã","–æ–Ω","–æ–Ω–∞","–æ–Ω–∏","–º—ã",
        # –º–æ–∂–Ω–æ —Ä–∞—Å—à–∏—Ä–∏—Ç—å –ø–æ–¥ –∑–∞–¥–∞—á–∏
    }

    def __init__(self, excel_path: str, sheet_name=0):
        """
        1. –°—á–∏—Ç—ã–≤–∞–µ–º Excel: –∫–æ–ª–æ–Ω–∫–∏ 'Question' –∏ 'Answer'.
        2. –ü—Ä–µ–¥–æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–∞–∂–¥—ã–π –≤–æ–ø—Ä–æ—Å: —Ç–æ–∫–µ–Ω–∏–∑–∏—Ä—É–µ–º, —É–±–∏—Ä–∞–µ–º —Å—Ç–æ–ø‚Äë—Å–ª–æ–≤–∞.
        3. –°—Ç—Ä–æ–∏–º TF-IDF –º–∞—Ç—Ä–∏—Ü—É:
           - idf[w] = log(N / df[w])
           - –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –¥–æ–∫—É–º–µ–Ω—Ç–∞ —Ö—Ä–∞–Ω–∏—Ç—Å—è dict: {w: tfidf(w, doc)}
        """
        df = pd.read_excel(excel_path, sheet_name=sheet_name)
        if not {"Question","Answer"}.issubset(df.columns):
            raise ValueError("–í Excel –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —Å—Ç–æ–ª–±—Ü—ã 'Question' –∏ 'Answer'")

        # –ß–∏—Ç–∞–µ–º –ø–∞—Ä—ã
        self.qa = []
        for q, a in zip(df['Question'].astype(str), df['Answer'].astype(str)):
            q_clean = q.strip()
            if not q_clean:
                continue
            tokens = self._tokenize(q_clean)
            tokens = [t for t in tokens if t not in self.STOP_WORDS]
            if not tokens:
                continue
            self.qa.append((tokens, a))

        # –í—Å–µ–≥–æ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤
        self.N = len(self.qa)

        # –°—á–∏—Ç–∞–µ–º –¥–æ–∫—É–º–µ–Ω—Ç–Ω—ã–µ —á–∞—Å—Ç–æ—Ç—ã df[w]
        df_counts: Dict[str, int] = {}
        for tokens, _ in self.qa:
            unique = set(tokens)
            for w in unique:
                df_counts[w] = df_counts.get(w, 0) + 1

        # –°—á–∏—Ç–∞–µ–º idf
        self.idf: Dict[str, float] = {}
        for w, dfw in df_counts.items():
            # –î–æ–±–∞–≤–ª—è–µ–º +1 –≤ –∑–Ω–∞–º–µ–Ω–∞—Ç–µ–ª–µ –¥–ª—è —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è
            self.idf[w] = math.log((self.N + 1) / (dfw + 1)) + 1.0

        # –°—Ç—Ä–æ–∏–º TF-IDF –≤–µ–∫—Ç–æ—Ä—ã –∏ –∏—Ö –Ω–æ—Ä–º—ã
        self.doc_tfidf: List[Dict[str, float]] = []
        self.doc_norm: List[float] = []
        for tokens, _ in self.qa:
            tf = Counter(tokens)
            # —Å—Ç—Ä–æ–∏–º tf-idf: tfidf = tf[w] * idf[w]
            vec = {w: tf[w] * self.idf[w] for w in tf}
            norm = math.sqrt(sum(v * v for v in vec.values()))
            self.doc_tfidf.append(vec)
            self.doc_norm.append(norm)

    @staticmethod
    def _tokenize(text: str) -> List[str]:
        """
        –£–±–∏—Ä–∞–µ–º –≤—Å–µ, –∫—Ä–æ–º–µ –±—É–∫–≤ –∏ —Ü–∏—Ñ—Ä, –ø—Ä–∏–≤–æ–¥–∏–º –∫ –Ω–∏–∂–Ω–µ–º—É —Ä–µ–≥–∏—Å—Ç—Ä—É,
        —Ä–∞–∑–±–∏–≤–∞–µ–º –ø–æ –ø—Ä–æ–±–µ–ª–∞–º.
        """
        text = re.sub(r'[^0-9A-Za-z–ê-–Ø–∞-—è–Å—ë]+', ' ', text.lower())
        return [tok for tok in text.split() if tok]

    @staticmethod
    def _cosine(vec1: Dict[str, float], vec2: Dict[str, float],
                norm1: float, norm2: float) -> float:
        """
        –ö–æ—Å–∏–Ω—É—Å–Ω–æ–µ —Å—Ö–æ–¥—Å—Ç–≤–æ: dot(vec1, vec2) / (norm1 * norm2)
        –ï—Å–ª–∏ –æ–¥–∏–Ω –∏–∑ –≤–µ–∫—Ç–æ—Ä–æ–≤ –Ω—É–ª–µ–≤–æ–π, –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç 0.0
        """
        if norm1 == 0 or norm2 == 0:
            return 0.0
        # –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ –∫–ª—é—á–µ–π
        dot = sum(vec1[k] * vec2.get(k, 0.0) for k in vec1)
        return dot / (norm1 * norm2)

    def find_best_answer(self, query: str, threshold: float = 0.2) -> str:
        """
        –ò—â–µ–º –ª—É—á—à–∏–π –æ—Ç–≤–µ—Ç –Ω–∞ query:
        1. –¢–æ–∫–µ–Ω–∏–∑–∏—Ä—É–µ–º –∏ —Ñ–∏–ª—å—Ç—Ä—É–µ–º query.
        2. –°—Ç—Ä–æ–∏–º tf-idf –≤–µ–∫—Ç–æ—Ä –¥–ª—è query (–∏—Å–ø–æ–ª—å–∑—É–µ–º idf –∏–∑ –∫–æ—Ä–ø—É—Å–∞).
        3. –°—á–∏—Ç–∞–µ–º –∫–æ—Å–∏–Ω—É—Å–Ω–æ–µ —Å—Ö–æ–¥—Å—Ç–≤–æ —Å –∫–∞–∂–¥—ã–º –¥–æ–∫—É–º–µ–Ω—Ç–æ–º.
        4. –ï—Å–ª–∏ max(sim) >= threshold, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Å–≤—è–∑–∞–Ω–Ω—ã–π answer,
           –∏–Ω–∞—á–µ ‚Äî –æ—Ç–∫–∞–∑.
        """
        # –ü—Ä–µ–¥–æ–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–ø—Ä–æ—Å–∞
        tokens = self._tokenize(query)
        tokens = [t for t in tokens if t not in self.STOP_WORDS]
        if not tokens:
            return "–ò–∑–≤–∏–Ω–∏—Ç–µ, —è –ø–æ–∫–∞ –Ω–µ –º–æ–≥—É –æ—Ç–≤–µ—Ç–∏—Ç—å –Ω–∞ —ç—Ç–æ—Ç –≤–æ–ø—Ä–æ—Å."

        # tf –¥–ª—è –∑–∞–ø—Ä–æ—Å–∞
        tfq = Counter(tokens)
        # —Å—Ç—Ä–æ–∏–º –≤–µ–∫—Ç–æ—Ä query
        vecq = {w: tfq[w] * self.idf.get(w, math.log((self.N+1)/1)+1.0)
                for w in tfq}
        normq = math.sqrt(sum(v * v for v in vecq.values()))

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥–æ–µ doc
        best_idx, best_sim = -1, 0.0
        for i, (doc_vec, doc_norm) in enumerate(zip(self.doc_tfidf, self.doc_norm)):
            sim = self._cosine(vecq, doc_vec, normq, doc_norm)
            if sim > best_sim:
                best_sim = sim
                best_idx = i

        # –ï—Å–ª–∏ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø–æ—Ö–æ–∂–∏ ‚Äî –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—Ç–≤–µ—Ç
        if best_sim >= threshold and best_idx >= 0:
            return self.qa[best_idx][1]

        return "–ò–∑–≤–∏–Ω–∏—Ç–µ, —è –ø–æ–∫–∞ –Ω–µ –º–æ–≥—É –æ—Ç–≤–µ—Ç–∏—Ç—å –Ω–∞ —ç—Ç–æ—Ç –≤–æ–ø—Ä–æ—Å."


# -------------
# –ü—Ä–∏–º–µ—Ä
# -------------
if __name__ == "__main__":
    kb = KnowledgeBase("knowledge_base.xlsx")
    print("–ë–∞–∑–∞ –∑–∞–≥—Ä—É–∂–µ–Ω–∞. –í–≤–µ–¥–∏—Ç–µ –≤–æ–ø—Ä–æ—Å:")
    while True:
        q = input("> ").strip()
        if not q:
            break
        print("–ë–æ—Ç:", kb.find_best_answer(q, threshold=0.2))









# handlers/admin_commands.py

from dialog_bot_sdk.entities.messaging import CommandHandler
from dialog_bot_sdk.entities.peers     import PeerType
from config.config                    import ADMIN_IDS
from infrastructure.sber_sdk           import sber_bot
from infrastructure.excel_repository   import ExcelRepository

# –ü—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º, —á—Ç–æ excel_repo —Å–æ–∑–¥–∞–Ω (–Ω–∞–ø—Ä–∏–º–µ—Ä, –≤ main –∏ –ø–µ—Ä–µ–¥–∞–Ω —Å—é–¥–∞)
excel_repo = ExcelRepository("knowledge_base.xlsx", "bot_logs.xlsx")

def is_admin(message):
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —á—Ç–æ sender_peer.id –µ—Å—Ç—å –≤ —Å–ø–∏—Å–∫–µ –∞–¥–º–∏–Ω–æ–≤."""
    return message.sender_peer.id in ADMIN_IDS

# --- –ö–æ–º–∞–Ω–¥–∞ 1: –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–æ–≤–æ–π –ø–∞—Ä—ã –í–æ–ø—Ä–æ—Å;–û—Ç–≤–µ—Ç ---
def add_qa_handler(update):
    # update: UpdateMessage
    peer   = update.peer
    sender = update.sender_peer

    if not is_admin(update):
        return sber_bot.messaging.send_message(peer, "‚ùå –¢–æ–ª—å–∫–æ –∞–¥–º–∏–Ω—ã –º–æ–≥—É—Ç —É–ø—Ä–∞–≤–ª—è—Ç—å –±–∞–∑–æ–π –∑–Ω–∞–Ω–∏–π.")

    # –æ–∂–∏–¥–∞–µ–º —Ç–µ–∫—Å—Ç –≤–∏–¥–∞: "–í–æ–ø—Ä–æ—Å?;–û—Ç–≤–µ—Ç!"
    payload = update.message.text_message.text
    try:
        # —É–±–∏—Ä–∞–µ–º –∫–æ–º–∞–Ω–¥—É "/add_qa " –≤ –Ω–∞—á–∞–ª–µ
        _, body = payload.split(" ", 1)
        question, answer = [p.strip() for p in body.split(";", 1)]
    except ValueError:
        return sber_bot.messaging.send_message(
            peer, "‚ùó –§–æ—Ä–º–∞—Ç: /add_qa –í–æ–ø—Ä–æ—Å?; –û—Ç–≤–µ—Ç!"
        )

    # –î–æ–±–∞–≤–ª—è–µ–º –≤ Excel (—Ä–µ–∞–ª–∏–∑—É–π—Ç–µ —ç—Ç–æ—Ç –º–µ—Ç–æ–¥ –≤ ExcelRepository)
    excel_repo.add_qa(question, answer)
    sber_bot.messaging.send_message(peer, f"‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–æ: ¬´{question}¬ª ‚Üí ¬´{answer}¬ª.")


# --- –ö–æ–º–∞–Ω–¥–∞ 2: —É–¥–∞–ª–µ–Ω–∏–µ –ø–∞—Ä—ã –ø–æ –≤–æ–ø—Ä–æ—Å—É ---
def delete_qa_handler(update):
    peer   = update.peer
    sender = update.sender_peer

    if not is_admin(update):
        return sber_bot.messaging.send_message(peer, "‚ùå –¢–æ–ª—å–∫–æ –∞–¥–º–∏–Ω—ã –º–æ–≥—É—Ç —É–ø—Ä–∞–≤–ª—è—Ç—å –±–∞–∑–æ–π –∑–Ω–∞–Ω–∏–π.")

    # –æ–∂–∏–¥–∞–µ–º —Ç–µ–∫—Å—Ç –≤–∏–¥–∞: "/del_qa –í–æ–ø—Ä–æ—Å?"
    parts = update.message.text_message.text.split(" ", 1)
    if len(parts) < 2 or not parts[1].strip():
        return sber_bot.messaging.send_message(peer, "‚ùó –§–æ—Ä–º–∞—Ç: /del_qa –í–æ–ø—Ä–æ—Å?")
    question = parts[1].strip()

    # –£–¥–∞–ª—è–µ–º –≤ Excel (—Ä–µ–∞–ª–∏–∑—É–π—Ç–µ —ç—Ç–æ—Ç –º–µ—Ç–æ–¥)
    deleted = excel_repo.delete_qa(question)
    if deleted:
        sber_bot.messaging.send_message(peer, f"üóë –ü–∞—Ä–∞ —Å –≤–æ–ø—Ä–æ—Å–æ–º ¬´{question}¬ª —É–¥–∞–ª–µ–Ω–∞.")
    else:
        sber_bot.messaging.send_message(peer, f"‚ùå –ù–µ –Ω–∞—à—ë–ª –≤–æ–ø—Ä–æ—Å ¬´{question}¬ª –≤ –±–∞–∑–µ.")


# --- –ö–æ–º–∞–Ω–¥–∞ 3: –æ—Ç–ø—Ä–∞–≤–∫–∞ Excel-—Ñ–∞–π–ª–∞ –±–∞–∑—ã –∑–Ω–∞–Ω–∏–π ---
def export_kb_handler(update):
    peer   = update.peer
    sender = update.sender_peer

    if not is_admin(update):
        return sber_bot.messaging.send_message(peer, "‚ùå –¢–æ–ª—å–∫–æ –∞–¥–º–∏–Ω—ã –º–æ–≥—É—Ç –≤—ã–≥—Ä—É–∂–∞—Ç—å –±–∞–∑—É –∑–Ω–∞–Ω–∏–π.")

    path = excel_repo.kb_path  # –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É knowledge_base.xlsx
    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ñ–∞–π–ª –≤ —á–∞—Ç
    sber_bot.messaging.send_file(peer, path, text="üì¶ –í–æ—Ç –∞–∫—Ç—É–∞–ª—å–Ω–∞—è –±–∞–∑–∞ –∑–Ω–∞–Ω–∏–π:")





from dialog_bot_sdk.entities.messaging import CommandHandler
from dialog_bot_sdk.entities.peers     import PeerType
from infrastructure.sber_sdk           import sber_bot
from handlers.admin_commands           import (
    add_qa_handler,
    delete_qa_handler,
    export_kb_handler,
)

# –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –∫–æ–º–∞–Ω–¥—ã (—Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∞–º, –Ω–æ PeerType.PEERTYPE_PRIVATE —É–¥–æ–±–Ω–µ–µ)
sber_bot.messaging.command_handler([
    CommandHandler(add_qa_handler,    "add_qa",  PeerType.PEERTYPE_PRIVATE, description="–î–æ–±–∞–≤–∏—Ç—å –≤–æ–ø—Ä–æ—Å;–æ—Ç–≤–µ—Ç"),
    CommandHandler(delete_qa_handler, "del_qa",  PeerType.PEERTYPE_PRIVATE, description="–£–¥–∞–ª–∏—Ç—å –ø–æ –≤–æ–ø—Ä–æ—Å—É"),
    CommandHandler(export_kb_handler, "export_kb", PeerType.PEERTYPE_PRIVATE, description="–í—ã–≥—Ä—É–∑–∏—Ç—å Excel –±–∞–∑—ã –∑–Ω–∞–Ω–∏–π"),
])




from openpyxl import load_workbook

class ExcelRepository:
    def __init__(self, kb_path: str, log_path: str):
        self.kb_path  = kb_path
        # ‚Ä¶ –æ—Å—Ç–∞–ª—å–Ω–æ–π –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä

    def add_qa(self, question: str, answer: str):
        """–î–æ–±–∞–≤–ª—è–µ—Ç –Ω–æ–≤—É—é —Å—Ç—Ä–æ–∫—É –≤ –Ω–∞—á–∞–ª–æ/–∫–æ–Ω–µ—Ü –ª–∏—Å—Ç–∞ –±–∞–∑—ã –∑–Ω–∞–Ω–∏–π."""
        wb = load_workbook(self.kb_path)
        ws = wb.active
        ws.append([question, answer])
        wb.save(self.kb_path)

    def delete_qa(self, question: str) -> bool:
        """
        –£–¥–∞–ª—è–µ—Ç –ø–µ—Ä–≤—É—é –Ω–∞–π–¥–µ–Ω–Ω—É—é —Å—Ç—Ä–æ–∫—É, –≥–¥–µ –∫–æ–ª–æ–Ω–∫–∞ 'Question' == question.
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç True, –µ—Å–ª–∏ —É–¥–∞–ª–∏–ª–∏, –∏–Ω–∞—á–µ False.
        """
        wb = load_workbook(self.kb_path)
        ws = wb.active
        found = False
        # –ò—â–µ–º –≤–æ –≤—Å–µ—Ö —Å—Ç—Ä–æ–∫–∞—Ö, –Ω–∞—á–∏–Ω–∞—è —Å 2‚Äë–π (–ø—Ä–æ–ø—É—Å–∫–∞–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫)
        for row in list(ws.iter_rows(min_row=2)):
            cell = row[0]  # –ø–µ—Ä–≤—ã–π —Å—Ç–æ–ª–±–µ—Ü ‚Äî –≤–æ–ø—Ä–æ—Å
            if str(cell.value).strip() == question:
                ws.delete_rows(cell.row, 1)
                found = True
                break
        if found:
            wb.save(self.kb_path)
        return found




























from dialog_bot_sdk.entities.messaging import CommandHandler, MessageHandler, MessageContentType
from dialog_bot_sdk.entities.peers     import PeerType
from infrastructure.sberchat.sber_bot   import sber_bot

# ‚Ä¶ –≤–∞—à–∏ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –∏–º–ø–æ—Ä—Ç—ã –∏ —Ö–µ–Ω–¥–ª–µ—Ä—ã ‚Ä¶

def get_peer(update):
    """
    –ö–æ–º–∞–Ω–¥–∞ /get_peer ‚Äî –±–æ—Ç —à–ª—ë—Ç –æ–±—Ä–∞—Ç–Ω–æ peer.id –∏ peer.type
    –†–∞–±–æ—Ç–∞–µ—Ç –∏ –≤ –õ–°, –∏ –≤ –≥—Ä—É–ø–ø–µ.
    """
    peer = update.peer
    # –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø—Ä–æ—Å—Ç–æ–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
    text = f"Peer ID: {peer.id}\nPeer Type: {peer.type.name}"
    sber_bot.messaging.send_message(peer, text)

# –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –∫–æ–º–∞–Ω–¥—É
sber_bot.messaging.command_handler([
    # –≤–∞—à–∞ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∞—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è MessageHandler
    MessageHandler(handle_message, MessageContentType.TEXT_MESSAGE),
    # —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º /get_peer –¥–ª—è –õ–° –∏ –¥–ª—è –ì—Ä—É–ø–ø—ã
    CommandHandler(get_peer, "get_peer", PeerType.PEERTYPE_PRIVATE,
                   description="–í—ã–≤–µ—Å—Ç–∏ peer.id –∏ peer.type"),
    CommandHandler(get_peer, "get_peer", PeerType.PEERTYPE_GROUP,
                   description="–í—ã–≤–µ—Å—Ç–∏ peer.id –∏ peer.type"),
])
